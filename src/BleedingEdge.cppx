#include "FrozenWasteland.hpp"
#include "dsp/functions.hpp"
#include "dsp/samplerate.hpp"
#include "dsp/ringbuffer.hpp"
#include "dsp/filter.hpp"
#include "pffft/pffft.h"

#define BLOCKSIZE 640
#define HOPSIZE 256

struct RealTimeConvolver {
	// `kernelBlocks` number of contiguous FFT blocks of size `blockSize`
	// indexed by [i * blockSize*2 + j]
	float *inputFfts = NULL;
	float *outputTail = NULL;
	float *tmpBlock = NULL;
	float *TPlus = NULL;
	float *TMinus = NULL;
	float *TemporalChange = NULL; //F(i,j) in paper
	float *delayTime = NULL;
	float *feedbackAmount = NULL;
	size_t blockSize;
	size_t kernelBlocks = 1;
	size_t inputPos = 0;
	bool windowsValid = false;
	// kiss_fftr_cfg fft_cfg;
	// kiss_fftr_cfg ifft_cfg;
	PFFFT_Setup *pffft;

	/** blocksize should be >=32 and a power of 2 */
	RealTimeConvolver(size_t blockSize) {
		this->blockSize = blockSize;
		pffft = pffft_new_setup(blockSize*2, PFFFT_REAL);
		inputFfts = (float*) pffft_aligned_malloc(sizeof(float) * blockSize*2);
		memset(inputFfts, 0, sizeof(float) * blockSize*2);
		outputTail = new float[blockSize]();
		tmpBlock = new float[blockSize*2]();		

		TPlus = new float[kernelBlocks * blockSize * 2]();	
		TMinus = new float[kernelBlocks * blockSize * 2]();	
		TemporalChange = new float[kernelBlocks * blockSize * 2]();	
	}

	~RealTimeConvolver() {
		clear();
		delete[] outputTail;
		delete[] tmpBlock;
		delete[] TPlus;
		delete[] TMinus;
		delete[] TemporalChange;
		pffft_destroy_setup(pffft);
	}

	void clear() {
		if (inputFfts) {
			pffft_aligned_free(inputFfts);
			inputFfts = NULL;
		}
		inputPos = 0;
	}

	void findTransients()
	{
		size_t prevInputPos = (inputPos - 1);
		if(prevInputPos < 0) {
			prevInputPos = kernelBlocks - 1;
		}
		size_t nextInputPos = (inputPos + 1) % kernelBlocks;

		size_t v = 3; //Smoothness 

		for(size_t k=0;k<blockSize;k++) {
			TMinus[blockSize*2*inputPos + k*2] = abs(inputFfts[blockSize*2 * inputPos + k*2]) - abs(inputFfts[blockSize*2 * prevInputPos + k*2]);
			TPlus[blockSize*2*inputPos + k*2] = abs(inputFfts[blockSize*2 * inputPos + k*2]) - abs(inputFfts[blockSize*2 * nextInputPos + k*2]);
		}

		for(size_t j=v;j<blockSize-v;j++) {
			size_t total = 0;
			for(size_t k=j-v;k<j+v;k++) {
				size_t sgnMinus = 1;
				size_t sgnPlus = 1;
				if (TMinus[k*2] < 0) {
					sgnMinus = -1;
				}
				if (TPlus[k*2] < 0) {
					sgnPlus = -1;
				}
				total = total + (1 + sgnMinus) * TMinus[k*2] + (1+ sgnPlus) * TPlus[k*2];
			}
			TemporalChange[blockSize*2*inputPos + j*2] = total / 2.0;
		}
	}


	/** Applies reverb to input
	input and output must be size blockSize
	*/
	void processBlock(const float *input, float *output) {
		///if (kernelBlocks == 0) {
		//memset(output, 0, sizeof(float) * blockSize);
		//	return;
		//}


		// Pad block with zeros
		memset(tmpBlock, 0, sizeof(float) * blockSize*2);
		memcpy(tmpBlock, input, sizeof(float) * blockSize);
		// Compute input fft
		pffft_transform(pffft, tmpBlock, &inputFfts[blockSize*2 * inputPos], NULL, PFFFT_FORWARD);
		// Create output fft
		memset(tmpBlock, 0, sizeof(float) * blockSize*2);

		if(windowsValid) {
			//findTransients();
		}

		// convolve input fft by kernel fft
		// Note: This is the CPU bottleneck loop
		// Note: This is where I need to add my code
		//for (size_t i = 0; i < kernelBlocks; i++) {
		//	size_t pos = (inputPos - i + kernelBlocks) % kernelBlocks;
		//	pffft_zconvolve_accumulate(pffft, &kernelFfts[blockSize*2 * i], &inputFfts[blockSize*2 * pos], tmpBlock, 1.0);
		//}


		// Compute output
		pffft_transform(pffft, inputFfts, tmpBlock, NULL, PFFFT_BACKWARD);
		// Add block tail from last output block
		for (size_t i = 0; i < blockSize; i++) {
			tmpBlock[i] += outputTail[i];
		}
		// Copy output block to output
		for (size_t i = 0; i < blockSize; i++) {
			// Scale based on FFT
			output[i] = tmpBlock[i] / blockSize;
		}
		// Set tail
		for (size_t i = 0; i < blockSize; i++) {
			outputTail[i] = tmpBlock[i + blockSize];
		}

		// Step input position
		inputPos = (inputPos + 1) % kernelBlocks;
		if(inputPos == 0) {
			windowsValid = true; //if we have cycled through kernalBlocks # of frames, we are good
		}

	}
};




struct BleedingEdge : Module {
	enum ParamIds {
		SMOOTHENESS_PARAM,
		NUM_PARAMS
	};
	enum InputIds {
		SIGNAL_IN,		
		NUM_INPUTS
	};
	enum OutputIds {
		TRANSIENT_OUTPUT,
		TONAL_OUTPUT,
		NUM_OUTPUTS
	};

	RealTimeConvolver *convolver = NULL;
	SampleRateConverter<1> inputSrc;
	SampleRateConverter<1> outputSrc;
	DoubleRingBuffer<Frame<1>, 16*BLOCKSIZE> inputBuffer;
	DoubleRingBuffer<Frame<1>, 16*BLOCKSIZE> outputBuffer;

	BleedingEdge() : Module(NUM_PARAMS, NUM_INPUTS, NUM_OUTPUTS) {
		convolver = new RealTimeConvolver(BLOCKSIZE);
		//convolver->setKernel(springReverbIR, springReverbIRLen);
	}

	void process(const ProcessArgs &args) override;
};

void BleedingEdge::process(const ProcessArgs &args) {
	
	float signalIn = inputs[SIGNAL_IN].getVoltage();
//	const float levelScale = 0.030;
//	const float levelBase = 25.0;
//	float level1 = levelScale * exponentialBipolar(levelBase, params[LEVEL1_PARAM].getValue()) * inputs[CV1_INPUT].normalize(10.0) / 10.0;
//	float level2 = levelScale * exponentialBipolar(levelBase, params[LEVEL2_PARAM].getValue()) * inputs[CV2_INPUT].normalize(10.0) / 10.0;
//	float dry = in1 * level1 + in2 * level2;


	// Add dry to input buffer
	if (!inputBuffer.full()) {
		Frame<1> inputFrame;
		inputFrame.samples[0] = signalIn;
		inputBuffer.push(inputFrame);
	}


	if (outputBuffer.size() <= BLOCKSIZE-HOPSIZE) {
		float input[BLOCKSIZE] = {};
		float output[BLOCKSIZE];
		// Convert input buffer
		{
			inputSrc.setRates(args.sampleRate, 48000);
			int inLen = inputBuffer.size();
			int outLen = BLOCKSIZE;
			inputSrc.process(inputBuffer.startData(), &inLen, (Frame<1>*) input, &outLen);
			inputBuffer.startIncr(inLen);
		}

		// Convolve block
		convolver->processBlock(input, output);

		// Convert output buffer
		{
			outputSrc.setRates(48000, args.sampleRate);
			int inLen = BLOCKSIZE;
			int outLen = outputBuffer.capacity();
			outputSrc.process((Frame<1>*) output, &inLen, outputBuffer.endData(), &outLen);
			outputBuffer.endIncr(outLen);
		}
	}

	// Set output
	if (outputBuffer.empty())
		return;
	float wet = outputBuffer.shift().samples[0];
	float balance = clamp(params[SMOOTHENESS_PARAM].getValue(), 0.0f, 1.0f);
	float mix = crossfade(signalIn, wet, balance);

	outputs[TRANSIENT_OUTPUT].setVoltage(clamp(wet, -10.0f, 10.0f));
	outputs[TONAL_OUTPUT].setVoltage(clamp(mix, -10.0f, 10.0f));
		
}







struct BleedingEdgeWidget : ModuleWidget {
	BleedingEdgeWidget(BleedingEdge *module);
};

BleedingEdgeWidget::BleedingEdgeWidget(BleedingEdge *module) {
		setModule(module);
	box.size = Vec(15*9, 380);

	{
		SVGPanel *panel = new SVGPanel();
		panel->box.size = box.size;
		panel->setBackground(APP->window->loadSvg(asset::plugin(pluginInstance, "res/BleedingEdge.svg")));
		addChild(panel);
	}
		
	addParam(createParam<RoundBlackKnob>(Vec(14, 84), module, BleedingEdge::SMOOTHENESS_PARAM, 0, 1.0, .25));

	addInput(Port::create<PJ301MPort>(Vec(10, 172), Port::INPUT, module, BleedingEdge::SIGNAL_IN));

	addOutput(Port::create<PJ301MPort>(Vec(10, 222), Port::OUTPUT, module, BleedingEdge::TRANSIENT_OUTPUT));
	addOutput(Port::create<PJ301MPort>(Vec(10, 273), Port::OUTPUT, module, BleedingEdge::TONAL_OUTPUT));

	addChild(Widget::create<ScrewSilver>(Vec(RACK_GRID_WIDTH-12, 0)));
	addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH + 12, 0)));
	addChild(Widget::create<ScrewSilver>(Vec(RACK_GRID_WIDTH-12, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
	addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 2 * RACK_GRID_WIDTH + 12, RACK_GRID_HEIGHT - RACK_GRID_WIDTH)));
}

Model *modelBleedingEdge = Model::create<BleedingEdge, BleedingEdgeWidget>("Frozen Wasteland", "BleedingEdge", "BleedingEdge", FILTER_TAG);
